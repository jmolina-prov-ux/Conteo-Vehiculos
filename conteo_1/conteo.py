# -*- coding: utf-8 -*-
"""Prueba YOLO Conteo Vehiculos 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Iw2MhI8C87cs8CsW9RVoz3rDq-lnWq7d
"""

from google.colab import drive
import shutil
import os

# 1. Montar Google Drive
print("Montando Google Drive...")
drive.mount('/content/drive')
print("Google Drive montado.")

# 2. Definir las rutas
# Ruta de la carpeta en Google Drive que quieres copiar
# ¡ASEGÚRATE DE CAMBIAR 'NombreDeTuCarpeta' por el nombre REAL de tu carpeta en Drive!
# Si está anidada, por ejemplo, 'MisDocumentos/DatosImportantes', usa esa ruta.
ruta_origen_drive = "/content/drive/MyDrive/MTC DATA/PRUEBAS ML/YOLO"

# Ruta de destino en el entorno de Colab
# Esta creará una carpeta con el mismo nombre en la raíz de tu sesión de Colab
ruta_destino_colab = '/content/data' # Puedes cambiar el nombre aquí si quieres

# 3. Verificar si la carpeta de origen existe en Drive
if not os.path.exists(ruta_origen_drive):
    print(f"Error: La carpeta de origen '{ruta_origen_drive}' no existe en tu Google Drive.")
    print("Asegúrate de que la ruta sea correcta y que la carpeta exista.")
else:
    # 4. Copiar la carpeta
    print(f"\nCopiando la carpeta '{ruta_origen_drive}' a '{ruta_destino_colab}'...")
    try:
        # shutil.copytree es ideal para copiar directorios completos
        shutil.copytree(ruta_origen_drive, ruta_destino_colab)
        print(f"Copia completada exitosamente. Contenido de '{ruta_destino_colab}':")
        for item in os.listdir(ruta_destino_colab):
            print(f"  - {item}")
    except FileExistsError:
        print(f"La carpeta de destino '{ruta_destino_colab}' ya existe. No se copiará.")
        print("Si deseas copiarla de nuevo, primero elimina la carpeta existente en Colab.")
    except Exception as e:
        print(f"Ocurrió un error durante la copia: {e}")

# 5. Desmontar Google Drive
print("\nDesmontando Google Drive...")
drive.flush_and_unmount()
print("Google Drive desmontado. Ahora los datos de tu Drive no son accesibles desde esta sesión de Colab.")

# 6. Verificación (opcional): Intenta acceder a la carpeta original en Drive
# Esto debería fallar o mostrar que la ruta no existe, confirmando que se desmontó.
# print("\nIntentando acceder a la ruta de Drive después de desmontar (esto debería fallar):")
# if os.path.exists(ruta_origen_drive):
#    print(f"¡Advertencia! La ruta de Drive '{ruta_origen_drive}' aún existe. Posible error al desmontar.")
# else:
#    print(f"La ruta de Drive '{ruta_origen_drive}' no es accesible, lo que confirma que Drive se desmontó.")

print("\nOperación finalizada. Tus datos están ahora en el entorno de Colab.")

# --- 0) Instalación (Colab) ---
!pip -q install ultralytics>=8.3.0 opencv-python pandas numpy

# --- 1) Imports y configuración ---
from ultralytics import YOLO
import cv2, torch, os, time
import numpy as np
import pandas as pd
from collections import defaultdict

VIDEO_PATH = "/content/data/003.MP4"   # <-- tu video
OUT_VIDEO  = "/content/detections_003.mp4"
MODEL_NAME = "yolo11n.pt"              # puedes subir a yolo11s.pt / yolo11m.pt / yolo11x.pt
CONF_THRES = 0.25
IOU_THRES  = 0.5
USE_TRACKING = True                    # True: estima IDs únicos con ByteTrack (POC)
TARGET_CLASSES = {"car", "truck", "bus", "motorcycle", "train"}  # puedes ajustar

assert os.path.exists(VIDEO_PATH), f"No se encontró el archivo: {VIDEO_PATH}"

device = 0 if torch.cuda.is_available() else "cpu"
print("Dispositivo:", "GPU" if device == 0 else "CPU")

# Carga modelo YOLOv11
model = YOLO(MODEL_NAME)

# Nombres de clases del modelo (COCO)
names = getattr(model, "names", None)
if names is None:
    names = getattr(getattr(model, "model", object), "names", None)
if names is None:
    raise RuntimeError("No se pudo obtener el diccionario de clases del modelo.")

# Mapea clases objetivo a IDs
target_ids = [i for i, n in (names.items() if isinstance(names, dict) else enumerate(names))
              if n in TARGET_CLASSES]
print("Clases objetivo e IDs:", [(i, names[i]) for i in target_ids])

# --- 2) Prepara el escritor de video ---
cap = cv2.VideoCapture(VIDEO_PATH)
fps = cap.get(cv2.CAP_PROP_FPS) or 30.0
w   = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
h   = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
cap.release()

fourcc = cv2.VideoWriter_fourcc(*"mp4v")
writer = cv2.VideoWriter(OUT_VIDEO, fourcc, fps, (w, h))
print(f"Video: {w}x{h} @ {fps:.2f} FPS | cuadros: {total_frames}")

# --- 3) Inference (detección o tracking) + acumulación de estadísticas ---
global_counts = defaultdict(int)                       # total detecciones por clase (suma en todos los cuadros)
unique_ids_by_class = {c: set() for c in TARGET_CLASSES}  # conteo único usando tracking (si está activado)
frame_stats = []                                       # resumen por cuadro

t0 = time.time()
frame_idx = -1

# stream=True entrega resultados por cuadro
iterator = (model.track if USE_TRACKING else model.predict)(
    source=VIDEO_PATH,
    stream=True,
    conf=CONF_THRES,
    iou=IOU_THRES,
    classes=target_ids,
    device=device,
    verbose=False,
    # tracking:
    **({"tracker": "bytetrack.yaml", "persist": True} if USE_TRACKING else {})
)

for result in iterator:
    frame_idx += 1

    # Dibuja anotaciones y escribe al video de salida
    annotated = result.plot()          # ndarray BGR con cajas y labels
    writer.write(annotated)

    # Extrae detecciones de este cuadro
    boxes = getattr(result, "boxes", None)
    per_frame = defaultdict(int)

    if boxes is not None and boxes.xyxy is not None and len(boxes) > 0:
        cls_ids = boxes.cls.int().tolist()
        confs   = boxes.conf.tolist() if boxes.conf is not None else [None]*len(cls_ids)
        # IDs de tracking (si aplica)
        ids = None
        if USE_TRACKING and hasattr(boxes, "id") and boxes.id is not None:
            ids = boxes.id.int().tolist()
        else:
            ids = [None]*len(cls_ids)

        for c_id, conf, obj_id in zip(cls_ids, confs, ids):
            cname = names[c_id] if isinstance(names, dict) else names[c_id]
            if cname not in TARGET_CLASSES:
                continue
            global_counts[cname] += 1
            per_frame[cname] += 1
            if USE_TRACKING and obj_id is not None:
                unique_ids_by_class[cname].add(int(obj_id))

    # Guarda resumen por cuadro
    row = {"frame": frame_idx, "total": sum(per_frame.values())}
    for c in TARGET_CLASSES:
        row[c] = per_frame.get(c, 0)
    frame_stats.append(row)

writer.release()
elapsed = time.time() - t0
print(f"Procesado en {elapsed:.2f}s  (~{(frame_idx+1)/elapsed:.2f} FPS efectivos)")
print(f"Video anotado guardado en: {OUT_VIDEO}")

# --- 4) Estadísticas de resumen y CSV ---
df = pd.DataFrame(frame_stats).fillna(0).astype({c:int for c in ["frame"] + list(TARGET_CLASSES)})
totals = {c: int(global_counts.get(c, 0)) for c in TARGET_CLASSES}
avg_per_frame = {c: float(df[c].mean()) for c in TARGET_CLASSES}
max_frame = int(df.loc[df["total"].idxmax(), "frame"]) if len(df) else -1
max_total_in_frame = int(df["total"].max()) if len(df) else 0

summary_rows = []
for c in TARGET_CLASSES:
    summary_rows.append({
        "clase": c,
        "detecciones_totales": totals.get(c, 0),
        "promedio_por_cuadro": round(avg_per_frame.get(c, 0.0), 3),
        "objetos_unicos_estimados": (len(unique_ids_by_class[c]) if USE_TRACKING else None)
    })
summary_df = pd.DataFrame(summary_rows).sort_values("detecciones_totales", ascending=False)

# Guarda CSVs
os.makedirs("/content/results", exist_ok=True)
df.to_csv("/content/results/detecciones_por_cuadro.csv", index=False)
summary_df.to_csv("/content/results/resumen_vehiculos.csv", index=False)

print("\n=== RESUMEN GLOBAL ===")
print(summary_df.to_string(index=False))
print(f"\nCuadro con mayor densidad: frame #{max_frame} (total={max_total_in_frame})")
print("\nArchivos:")
print(" - /content/detections_003.mp4")
print(" - /content/results/resumen_vehiculos.csv")
print(" - /content/results/detecciones_por_cuadro.csv")

# --- 5) (Opcional) Gráfico rápido de barras ---
import matplotlib.pyplot as plt

fig = plt.figure(figsize=(6,4))
plt.bar(summary_df["clase"], summary_df["detecciones_totales"])
plt.title("Detecciones totales por clase")
plt.xlabel("Clase")
plt.ylabel("Detecciones")
plt.xticks(rotation=0)
plt.show()

from google.colab import files

files.download('/content/detections_003.mp4')